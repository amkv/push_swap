/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   notes.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: akalmyko <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2017/01/23 17:03:37 by akalmyko          #+#    #+#             */
/*   Updated: 2017/01/23 17:03:40 by akalmyko         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

static int 			*ft_array_copy(int *array, int size)
{
	int 			index;
	int 			*copy;

	if (!array || size <= 0)
		return (NULL);
	if (!(copy = (int*)malloc(sizeof(int) * size)))
		return (NULL);
	index = 0;
	while (index < size)
	{
		copy[index] = array[index];
		index++;
	}
	return (copy);
}

static int 			ft_spec_check_order(t_stack *stks)
{
	int 			index;
	int 			min;
	int 			min_index;

	index = 0;
	min_index = 0;
	min = stks->stk_a[0];
	while (index < stks->elems_a)
	{
		if (stks->stk_a[index] < min)
		{
			min = stks->stk_a[index];
			min_index = index;
		}
		index++;
	}

	return (0);
}

static int			ft_is_stack_in_decrease_order(int *b, int size)
{
	int 	index;

	index = 0;
	while (index < size)
	{
		if (index + 1 > size)
			break ;
		if (b[index] > b[index + 1])
			index++;
		else
			return (0);
	}
	return (1);
}

//Инициализированный стэк.
//- Проверить, является ли top_a самым большим числов в стеке stk_a
//    и stk_b является пустым
//    если так, то перенести его в stk_b (одна операция)
//- Проверить, можно ли сделать хоть какую-то сортиро

//static t_stack		*ft_set_the_fake_values(t_stack *stks, int index)
//{
//	t_stack			*fake;
//
//	if (!(fake = (t_stack*)malloc(sizeof(t_stack) * 1)))
//		return (NULL);
//	fake->stk_a = stks->stk_a;
//	fake->stk_b = stks->stk_b;
//	fake->size = stks->size;
//	fake->top_a = stks->top_a;
//	fake->top_b = stks->top_b;
//	fake->elems_a = stks->elems_a;
//	fake->elems_b = stks->elems_b;
//	return (fake);
//}

/*
 * main алгоритм выполняет следующее:
 * принимает как аргумент структуру stks
 * на выходе возвращает номер ошибки:
 * -1 если произошла ошибка при выполнении алгоритма
 * 1  если ошибок не произошло и функция закончила свое действие
 *
 * external переменная
 * Запускает while loop пока для всех чисел не найдется свое место
 *
 * internal переменная
 * инициализируется в начале index-ом external переменной
 *
 * *answers - это связанный лист операций, которые необходимо применить к стеку
 * порядок операций создается путем перебора всех возможных комбинаций
 * самый первый лист answers всегда содержит информацию о количестве операций
 *
 * num_oper - переменная которая извлекается из листа *answers[index]->num
 * служит для сравнения всего количества возможных операций из массива
 * ответов *answers
 *
 * winner - index номер "победившей" структуры *answers с наименьшим кол-вом
 * операций для стека в данной конфигурации
 *
 *
 * Порядок чтения алгоритма:
 * инициализирую переменную external и присваиваю значение 0;
 *
 * запускаю while loop, пока external меньше количеству элементов в массиве
 * необходимо пройтись по каждому числу в массиве A и найти его место
 * применив соответствующую операцию(операции);
 *
 * присваиваю значение переменной internal равную external = 0;
 * присваиваю значение переменной winner = 0;
 * присваиваю значение переменной num_oper = 0;
 *
 * запускаю второй while loop, от топовой позиции А до конца массива
 * чтобы проверить и найти самый меньший вариант сортировки и/или переноса
 * числа в стек B
 *
 * Проверяю первое условие:
 * если возвращаемый результат присвоенный answers[internal] функций
 * ft_check_steps равен NULL (тоесть произошла какая-то ошибка и операций не
 * присвоено) - то возвращаю результат работы алгоритма -1. программа будет
 * завершена с ошибкой
 *
 * в другом случае, работа программы продолжается и answers[internal] содержит
 * какое-то кол-во операций с количеством операций записанных в переменной ->num
 *
 * если цикл является первым или вторым по счету
 * то цикл прекращается и происходит применение листа answers к структуре stks;
 *
 * следующее условие срабатывает всегда первый раз, и значения инициализируются
 * счетчик internal переходит к сл.числу в стеке A
 *
 * если результатом работы функции ft_check_steps
 * стал вариант с меньшим количеством операций
 * то происходит перенеициализация переменных winner и num_oper (для дальнейшего
 * сравнения следующих ответов answers
 *
 * Просчитав все варанты в такой конфигурации стека A
 * и применив наименьший из возвожных вариантов для этого шага сортировки
 * происходит увеличение индекса переменной external - тоесть переход
 * к следующему по счету элементу стека A
 *
 * пока алгоритм не пройдется по всем элементам
 *
 * на выходе из функции получается stks сформированный таким образом, что
 * все элементы находятся в стеке В в порядке убывания
 * и их необходимо все перенести в стек A, этим занимается функция push_swap
 * вызвавшая данную функцию
 */

static int 			ft_set_param(char ab, int **stack, int *top, t_stack *s)
{
	if (ab == 'a')
	{
		*stack = s->stk_a;
		*top = s->top_a;
	}
	else if (ab == 'b')
	{
		*stack = s->stk_b;
		*top = s->top_b;
	}
	else
		return (-1);
	return (0);
}

static void 		ft_write_steps(int win, t_stack *s, t_oper **steps, char ab)
{
	while (win != 0)
	{
		if (s->buf_a < s->buf_b)
		{
			if (ab == 'a')
				*steps = ft_add_step(*steps, 8);
			else if (ab == 'b')
				*steps = ft_add_step(*steps, 9);
		}
		else if (s->buf_a > s->buf_b)
		{
			if (ab == 'a')
				*steps = ft_add_step(*steps, 5);
			else if (ab == 'b')
				*steps = ft_add_step(*steps, 6);
		}
		else if (s->buf_a == s->buf_b)
		{
			if (ab == 'a')
				*steps = ft_add_step(*steps, 8);
			else if (ab == 'b')
				*steps = ft_add_step(*steps, 9);
		}
		win--;
	}
}

static int 			ft_move_down(t_stack *s, int *stack, int top, int index)
{
	int 			num;

	if (index == s->size)
		return (1);
	num = s->size - index + 1;
	return (num);
}

static int 			ft_move_up(t_stack *s, int *stack, int top, int index)
{
	int 			num;

	if (index == top)
		return (0);
	num = top - index;
	if (num)
		return (num);
	else
		return (-num);
}

t_oper				*ft_to_be_on_the_top(t_stack *s, char ab, int index)
{
	t_oper			*steps;
	int 			*stack;
	int 			top;
	int				winner;

	if (ft_set_param(ab, &stack, &top, s) == -1)
		return (NULL);
	steps = NULL;
	s->buf_a = ft_move_down(s, stack, top, index);
	s->buf_b = ft_move_up(s, stack, top, index);
	if (s->buf_a < s->buf_b)
		winner = s->buf_a;
	else
		winner = s->buf_b;
	if (winner == 0)
		return (NULL);
	ft_write_steps(winner, s, &steps, ab);
	return (steps);
}

/*
 * Функция ft_check_steps
 * ЭТО СТАТИЧНАЯ функция, она не должна производить реальных манипуляций со стеком
 * она ДОЛЖНА только ПРОСЧИТЫВАТЬ варианты и записывать их в листы *steps
 *
 * принимает две переменные:
 * структуру stks с содержанием всех необходимых значений
 * и порядковый номер index - это число в стеке A для которого необходимо
 * произвести расчет по самой короткой возможной сортировке в данной конфигурации
 * для стека A.
 *
 * На выходе функция возвращает историю необходимых операций
 *
 * Порядок работы функции:
 *
 * инициализация листа *steps = NULL;
 * инициализация fake копии структуры stks
 *
 * проверка первого условия
 * если это первое или второе число в стеке А, то небходимо просто применить
 * две операции переноса двух числе в стек В, это всегда стандартное начало
 * для этого алгоритма
 * функция возвращает steps с push b оператором
 *
 * инициализация и выделение память для fake структуры (копии stks)
 * НУЖНО ЛИ?
 *
 * Теперь:
 * Каждый раз, при вызове этой функции, в переменной INDEX будет содержаться
 * порядковый номер числа в стеке A, для которого необходимо произвести расчет
 * перемещения этого числа в стек В, где ему необходимо будет встать в строго
 * отведенное для него место. Стек B должен быть всегда отсортирован в порядке
 * убывания. Соответственно, числов из стека A должно найти свое место.
 * для этого необходима функция, возвращающая порядок операций для просчета
 * как вставить число в стек B
 *
 * но для начала необходимо просчитать, как числу в стеке А оказаться на вершине
 * стека А, чтобы к нему можно было применить операцию перемещения в стек B
 * первая функция, которая это проверяет - это функция ft_to_be_on_the_top
 * эта функция может быть применана затем и к стеку B. тоесть это универсальная
 * функция, которая высчитывает количество операций для числа, из его положения
 * чтобы быть на вершина стека.
 *
 * результатом этой операции будет история записанная в листы.
 *
 * вторая функция - это как поместить число в стек B из вершины стека А
 * результатом работы этой функции - тоже будет список записанный в листах
 *
 * так как на выходе работы этих функций получается два листа
 * то необходимо объединить эти листы в один, чтобы отдать как результат
 * необходима функция, которая будет проверять оба этих листа. и если будет
 * находить в обоих листах, что в данный момент времени они делают одну и ту же
 * операцию, например крутят стек, то данная операция может быть заменена как одна
 * тогда оба этих действия упраздняются - и на их место записывается одно общее
 * действие.
 *
 * в результате на выходе мы получаем один лист с необходимым количеством операций
 * этот лист и возвращается в вызвавшую функцию, где становится answer[index] и
 * учавствует в борьбе за звание самой минимальной допустимой сортировки стека
 * в данный момент времени в данной конфигурации
 */

/*
 * Проверки в функции ft_up_b
 *
 * проверяю первое и последнее число в стеке
 * МОЖНО ЛИ ПОСТАВИТЬ НА ВЕРШИНУ? ТЕ МЕЖДУ ПОСЛЕДНИМ И ПЕРВЫМ
 * те top_b и stks->size - 1;
 *
 * затем, если первая проверка false
 * МОЖНО ЛИ ВСТАВИТЬ МЕЖДУ ПЕРВЫМ И ВТОРЫМ
 * top_b и top_b + 1
 *
 * ПРОХОЖУ ПО ВСЕМУ СТЕКУ
 * пока top_b не дойдет до конца
 *
 *
 */